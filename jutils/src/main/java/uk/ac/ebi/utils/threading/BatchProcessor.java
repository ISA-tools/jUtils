package uk.ac.ebi.utils.threading;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import uk.ac.ebi.utils.exceptions.UnexpectedEventException;


/**  
 * <p>A simple class to manage processing of data in multi-thread mode.</p>
 * 
 * <p>The idea implemented here is that {@link #process(Object, Object...)} runs a loop where: 
 * 
 * <ul>
 *   <li>gets a data item from its input source of type S</li>
 *   <li>optionally transforms the data item and sends the result to the current destination of type D</li>
 *   <li>invokes {@link #handleNewTask(Object, boolean)}, which 
 *   {@link #decideNewTask(Object) decides} if it's time to issue a new {@link #getConsumer() processing thread}.
 *   The latter possibly create a new destination object, via {@link #getDestinationSupplier()} and hence
 *   the caller should assign the current destination to it.</li>
 * </ul></p>
 *
 * <p>Each new invocation performed by {@link #handleNewTask(Object, boolean)} consists of the creation of a new
 * task which is submitted an {@link #getExecutor() executor service} and hence the processing can happen in 
 * multi-thread mode.</p>
 * 
 * <p>{@link #process(Object, Object...)} should invoke {@link #waitExecutor(String)} after the loop above, to make
 * the parallel task executions complete.</p> This also resets the internal {@link ExecutorService}, which will be 
 * recreated (once) upon the first invocation of {@link #getExecutor()}. This behaviour ensures that {@link #process(Object)}
 * can be invoked multiple times reusing the same processor instance (normally that's not possible for 
 * an {@link ExecutorService} which of method {@link ExecutorService#awaitTermination(long, TimeUnit)} was called).</p> 
 * 
 * <p>You can find a usage example of this class in the <a href = "TODO">rdf-utils-jena package</a>.
 *  
 * @author brandizi
 * <dl><dt>Date:</dt><dd>1 Dec 2017</dd></dl>
 *
 */
public abstract class BatchProcessor<S, D>
{
	private Consumer<D> consumer;
	private Supplier<D> destinationSupplier;
	
	private Supplier<ExecutorService> executorFactory = HackedBlockingQueue::createExecutor;
	private ExecutorService executor;
	
	private long submittedTasks = 0;
	private AtomicLong completedTasks = new AtomicLong ();

	/** @see {@link #wrapTask(Runnable)} */
	protected long taskLogPeriod = 1000;
		
	protected Logger log = LoggerFactory.getLogger ( this.getClass () );
		
	
	/**
	 * <b>WARNING</b>: in addition to the behaviour explained above, this method should also invoke 
	 * {@link #waitExecutor(String)} and possibly {@link #reset()}.
	 */
	public abstract void process ( S source, Object... opts );

	public void process ( S source ) {
		this.process ( source, new Object [ 0 ] );
	}

		
	protected D handleNewTask ( D currentDest ) {
		return handleNewTask ( currentDest, false );
	}

	/**
	 * This is the method that possibly issues a new task, via the {@link #getExecutor()}, which runs 
	 * the {@link #consumer} against the current {@link #getDestinationSupplier() destination}.   
	 * 
	 * Note that your {@link #getConsumer() task handler} will be executed under the 
	 * {@link #wrapTask(Runnable) default wrapper}.  
	 * 
	 * @param forceFlush if true it flushes the data independently of {@link #getChunkSize()}.  
	 * 
	 */
	protected D handleNewTask ( D currentDest, boolean forceFlush )
	{
		if ( !( forceFlush || this.decideNewTask ( currentDest ) ) ) return currentDest;

		getExecutor ().submit ( wrapTask ( () -> consumer.accept ( currentDest ) ) );
		
		if ( ++this.submittedTasks % this.taskLogPeriod == 0 ) 
			log.info ( "{} tasks submitted", this.submittedTasks );
		
		return this.destinationSupplier.get ();
	}
	
	/**
	 * {@link #handleNewTask(Object, boolean)} decides to generate a new task based on the value returned
	 * by this.
	 * 
	 */
	protected abstract boolean decideNewTask ( D dest );

	/**
	 * Every new parallel task that is generated by {@link #process(Object)} and {@link #handleNewTask(Object, boolean)}
	 * runs this consumer.
	 */
	public Consumer<D> getConsumer ()
	{
		return consumer;
	}

	public BatchProcessor<S, D> setConsumer ( Consumer<D> consumer )
	{
		this.consumer = consumer;
		return this;
	}

	/**
	 * Every time that {@link #handleNewTask(Object, boolean)} decides it's time to work on a new 
	 * {@link #getConsumer() task} and destination D, this supplier is used to generate such new destination.
	 * 
	 */
	public Supplier<D> getDestinationSupplier ()
	{
		return destinationSupplier;
	}

	public BatchProcessor<S, D> setDestinationSupplier ( Supplier<D> destinationSupplier )
	{
		this.destinationSupplier = destinationSupplier;
		return this;
	}


	/**
	 * <p>The factory for the thread pool manager used by {@link #process(Object, Object...)}.</p>
	 * 
	 * <p>By default this is {@link HackedBlockingQueue#createExecutor()}. Normally you shouldn't need to 
	 * change this parameter, unless you want some particular execution policy.</p>
	 * 
	 */
	public Supplier<ExecutorService> getExecutorFactory () {
		return executorFactory;
	}

	public void setExecutorFactory ( Supplier<ExecutorService> executorFactory ) {
		this.executorFactory = executorFactory;
	}
	
	/**
	 * This is initialised using the first time you call it, by means of {@link #getExecutorFactory()}. If you 
	 * invoke {@link #waitExecutor(String)}, in {@link #process(Object, Object...)}, as recommended, the internal 
	 * {@link ExecutorService} returned by this is made to null again and then re-initialised by this method upon its
	 * next call.
	 */
	public ExecutorService getExecutor ()
	{
		if ( executor == null ) executor = this.executorFactory.get ();
		return executor;
	}

	/**
	 * <p>Waits that all the parallel jobs submitted to the processor are finished. It keeps polling
	 * {@link ExecutorService#isTerminated()} and invoking {@link ExecutorService#awaitTermination(long, TimeUnit)}.</p>
	 * 
	 * <p>As explained above, this resets the {@link ExecutorService} that is returned by {@link #getExecutor()}, so that
	 * the next time that method is invoked, it will get a new executor from {@link #getExecutorFactory()}.</p>
	 * 
	 * @param pleaseWaitMessage the message to be reported (via logger/INFO level) while waiting.
	 */
	protected void waitExecutor ( String pleaseWaitMessage )
	{
		ExecutorService executor = getExecutor ();
		executor.shutdown (); 

		// Wait to finish
		try
		{
			while ( !executor.isTerminated () ) 
			{
				log.info ( pleaseWaitMessage ); 
				executor.awaitTermination ( 5, TimeUnit.MINUTES );
			}
		}
		catch ( InterruptedException ex ) {
			throw new UnexpectedEventException ( 
				"Unexpected interruption while waiting for processor termination: " + ex.getMessage (), ex 
			);
		}
		
		this.executor = null;
	}
	
	/**
	 * Wraps the task into some common operations. At the moment,
	 * 
	 *   * wraps exception,
	 *   * logs the progress of completed tasks every {@link #taskLogPeriod} completed tasks.
	 *   
	 */
	protected Runnable wrapTask ( Runnable task )
	{
		return () -> 
		{
			try {
				task.run ();
			}
			catch ( Exception ex )
			{
				log.error ( 
					String.format ( 
						"Error while running batch processor thread %s: %s", 
						Thread.currentThread ().getName (), ex.getMessage () 
					),
					ex
				);
			}
			finally {
				long completed = this.completedTasks.incrementAndGet ();
				if ( completed % this.taskLogPeriod == 0 || completed == this.submittedTasks && this.getExecutor ().isShutdown () )
					log.info ( "{}/{} tasks completed", completed, this.submittedTasks );
			}
		};
	}
}
